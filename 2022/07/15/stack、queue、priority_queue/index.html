<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/Knous.png"/>
	<link rel="shortcut icon" href="/img/Knous.png">
	
			    <title>
    Knous
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="Knous" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 6.2.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">Knous</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/Linux/">Linux</a></li><li><a class="category-link" href="/categories/test/">test</a></li><li><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="关于我">
		                关于我
		            </a>
		        </li>
		        
		        <li>
		            <a href="/Learn/" title="学习记录">
		                学习记录
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/knous" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url();background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >stack、queue、priority_queue</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <hr>
<p>这篇文章主要目标：</p>
<p>stack、queue、priority_queue的介绍和使用</p>
<p>什么是容器适配器</p>
<hr>
<h1 id="stack的介绍及使用"><a href="#stack的介绍及使用" class="headerlink" title="stack的介绍及使用"></a>stack的介绍及使用</h1><p>早在几个月前，我就写过一篇文章来讲解和模拟实现stack，当时用的是C语言的版本，这里放上链接：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_60306111/article/details/123730529?spm=1001.2014.3001.5502" title="【数据结构】栈_Knous的博客-CSDN博客_数据结构栈">【数据结构】栈_Knous的博客-CSDN博客_数据结构栈</a></p>
<p>因为现在使用的是C++，这里就重新说一下</p>
<h2 id="stack的介绍"><a href="#stack的介绍" class="headerlink" title="stack的介绍"></a>stack的介绍</h2><p><a target="_blank" rel="noopener" href="https://m.cplusplus.com/reference/stack/stack/?kw=stack" title="stack - C++ Reference (cplusplus.com)">stack - C++ Reference (cplusplus.com)</a></p>
<p>基本可以参考这个网站，但因为是全英文，这里挑一下重点说：</p>
<blockquote>
<ol>
<li><p>stack是一种容器适配器，专门用在具有后进先出操作的上下文环境中，其删除只能从容器的一端进行元素的插入与提取操作。</p>
</li>
<li><p>stack是作为容器适配器被实现的，容器适配器即是对特定类封装作为其底层的容器，并提供一组特定的成员函数来访问其元素，将特定类作为其底层的，元素特定容器的尾部(即栈顶)被压入和弹出。</p>
</li>
<li><p>stack的底层容器可以是任何标准的容器类模板或者一些其他特定的容器类，这些容器类应该支持以下操作：</p>
</li>
</ol>
<p>empty：判空操作</p>
<p>back：获取尾部元素操作</p>
<p>push_back：尾部插入元素操作</p>
<p>pop_back：尾部删除元素操作</p>
<ol start="4">
<li>标准容器vector、deque、list均符合这些需求，默认情况下，如果没有为stack指定特定的底层容器，默认情况下使用deque。</li>
</ol>
</blockquote>
<blockquote>
<p>简单来说，stack是一种容器，这个容器可以用vector是实现，也可以用list实现，只要满足其基本操作需要，如果没有指定容器，就会用deque（双向循环队列）</p>
<p>其基本功能有尾插尾删，获得尾部数据及判空</p>
</blockquote>
<h2 id="stack的使用"><a href="#stack的使用" class="headerlink" title="stack的使用"></a>stack的使用</h2><p>这里说几个常用的函数</p>
<table>
<thead>
<tr>
<th>函数说明</th>
<th>接口说明</th>
</tr>
</thead>
<tbody><tr>
<td>stack()</td>
<td>构造空的栈</td>
</tr>
<tr>
<td>empty()</td>
<td>检测stack是否为空</td>
</tr>
<tr>
<td>size()</td>
<td>返回stack中元素的个数</td>
</tr>
<tr>
<td>top()</td>
<td>返回栈顶元素的引用</td>
</tr>
<tr>
<td>push()</td>
<td>将元素val压入stack中</td>
</tr>
<tr>
<td>pop()</td>
<td>将stack中尾部的元素弹出</td>
</tr>
</tbody></table>
<p>这里借一道题举例：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201147420.png"></p>
<p>让我们实现一个栈，这个栈支持一些基本的操作，其中稍有难度的是最后有获取最小元素，要在常数时间里面，也就是说我们不能采用遍历的办法，这里说一个解法：</p>
<p>我们创建两个栈，第一个来完成插入删除，第二个来完成获取最小值的情况，假设st1（常规操作）要插入值，那就用st2（最小值）来判断</p>
<p>假如st2为空，或者插入的这个值比st2上一个值小，那我们最小值就要更新，这个值就要尾插到st2里面，获取最小值的时候就直接返回st2的顶部元素</p>
<p>这里看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    //两个栈，st1完成常规操作，st2来找最小    </span><br><span class="line">    stack&lt;int&gt; st1, st2;</span><br><span class="line"></span><br><span class="line">    MinStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void push(int val) &#123;</span><br><span class="line">        //先插入st1</span><br><span class="line">        st1.push(val);</span><br><span class="line">        </span><br><span class="line">        //如果走到这一步，st1里面肯定有起码一个值，此时如果st2为空，说明最小值就是那个元素，如果st2不为空，说明里面已有最小值，这个时候判断，如果这个插入值比当前最小值小，那就插入，最小值就要更新</span><br><span class="line">        if(st2.empty() || val &lt;= st2.top())</span><br><span class="line">        &#123;</span><br><span class="line">            st2.push(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果删的st1的值刚好是最小值，那st2也要删除，如果不是就直接删除st1即可</span><br><span class="line">    void pop() &#123;</span><br><span class="line">        if(st1.top() == st2.top())</span><br><span class="line">        &#123;</span><br><span class="line">            st1.pop();</span><br><span class="line">            st2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        st1.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //直接返回st1即可</span><br><span class="line">    </span><br><span class="line">    int top() &#123;</span><br><span class="line">        return st1.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //最小值都在st2里面，返回st2即可</span><br><span class="line">    int getMin() &#123;</span><br><span class="line">        return st2.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T, class con = deque&lt;T&gt;&gt;</span><br><span class="line">	class stack</span><br><span class="line">	&#123;</span><br><span class="line">	public:</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	private:</span><br><span class="line">		con _con;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>



<p>一点一点看，首先这是一个模板，那就用一个T来接收类型，重点是后面的con，这个就是我们的适配器了，因为每次都要造轮子的话也太麻烦了，因为stack的基本操作可以用其他</p>
<p>vector、list实现，那为什么不直接拿来用呢？</p>
<p>所以就出现了这里的，con是一个类模板，这个默认的是用deque，如果不喜欢这个也可以改，不过暂时先用着</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>stack的插入也只有尾插一种，所以这里直接调用con的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void push(const T&amp; x)</span><br><span class="line">		&#123;</span><br><span class="line">			_con.push_back(x);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<p>直接调用对应接口，由上面的deque来帮我们解决问题</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void pop()</span><br><span class="line">		&#123;</span><br><span class="line">			_con.pop_back();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<h3 id="返回顶端元素"><a href="#返回顶端元素" class="headerlink" title="返回顶端元素"></a>返回顶端元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const T&amp; top()</span><br><span class="line">		&#123;</span><br><span class="line">			return _con.back();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<p>这里说一下，vector和list都有这个back函数，它的作用是返回最后的数据，这里正好直接用</p>
<p>看一下效果；</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201147110.png"></p>
<p>不是默认用的deque吗，我传个vector行不行？</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201147294.png"></p>
<p>当然可以</p>
<p>list：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201147170.png"></p>
<p>都没有问题</p>
<p>只要这里的类模板符合stack的需求，即尾部的插入删除，返回尾部元素等，都可以替换 </p>
<hr>
<h1 id="queue的介绍和使用"><a href="#queue的介绍和使用" class="headerlink" title="queue的介绍和使用"></a>queue的介绍和使用</h1><p>同样我写了一篇queue的c介绍和模拟实现，这里是链接：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_60306111/article/details/123761379?spm=1001.2014.3001.5502" title="【数据结构】队列_Knous的博客-CSDN博客">【数据结构】队列_Knous的博客-CSDN博客</a></p>
<p>同样，先放上较为官方的文档介绍，再说一下重点</p>
<p><a target="_blank" rel="noopener" href="https://m.cplusplus.com/reference/queue/queue/" title="queue - C++ Reference (cplusplus.com)">queue - C++ Reference (cplusplus.com)</a></p>
<blockquote>
<ol>
<li>队列是一种容器适配器，专门用于在FIFO上下文(先进先出)中操作，其中从容器一端插入元素，另一端提取元素。</li>
<li>队列作为容器适配器实现，容器适配器即将特定容器类封装作为其底层容器类，queue提供一组特定的成员函数来访问其元素。元素从队尾入队列，从队头出队列。</li>
<li>底层容器可以是标准容器类模板之一，也可以是其他专门设计的容器类。该底层容器应至少支持以下操作:</li>
</ol>
<p>empty：检测队列是否为空</p>
<p>size：返回队列中有效元素的个数</p>
<p>front：返回队头元素的引用</p>
<p>back：返回队尾元素的引用</p>
<p>push_back：在队列尾部入队列</p>
<p>pop_front：在队列头部出队列</p>
<ol start="4">
<li>标准容器类deque和list满足了这些要求。默认情况下，如果没有为queue实例化指定容器类，则使用标准容器deque</li>
</ol>
</blockquote>
<p>这里要提一下：</p>
<blockquote>
<p> queue不能使用vector来作为底层，因为queue要支持头删，而vector的头删效率太低，所以不建议使用</p>
</blockquote>
<h2 id="queue的使用"><a href="#queue的使用" class="headerlink" title="queue的使用"></a>queue的使用</h2><p>这里说几个基本函数：</p>
<table>
<thead>
<tr>
<th>函数声明</th>
<th>接口说明</th>
</tr>
</thead>
<tbody><tr>
<td>queue()</td>
<td>构造空的队列</td>
</tr>
<tr>
<td>empty()</td>
<td>检测队列是否为空，是返回true，否则返回false</td>
</tr>
<tr>
<td>size()</td>
<td>返回队列中有效元素的个数</td>
</tr>
<tr>
<td>front()</td>
<td>返回队头元素的引用</td>
</tr>
<tr>
<td>back()</td>
<td>返回队尾元素的引用</td>
</tr>
<tr>
<td>push()</td>
<td>在队尾将元素val入队列</td>
</tr>
<tr>
<td>pop()</td>
<td>将队头元素出队列</td>
</tr>
</tbody></table>
<h2 id="模拟实现-1"><a href="#模拟实现-1" class="headerlink" title="模拟实现"></a>模拟实现</h2><p>因为大体实现思路是跟stack差不多的，所以这里就直接放上代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T,class Con = deque&lt;T&gt;&gt;</span><br><span class="line">	class queue</span><br><span class="line">	&#123;</span><br><span class="line">	public:</span><br><span class="line">		void push(const T&amp; x)</span><br><span class="line">		&#123;</span><br><span class="line">			_con.push_back(x);</span><br><span class="line">		&#125;</span><br><span class="line">		const T&amp; front()</span><br><span class="line">		&#123;</span><br><span class="line">			return _con.front();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		const T&amp; back()</span><br><span class="line">		&#123;</span><br><span class="line">			return _con.back();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		size_t size()</span><br><span class="line">		&#123;</span><br><span class="line">			return _con.size();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		bool empty()</span><br><span class="line">		&#123;</span><br><span class="line">			return _con.empty();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		void pop()</span><br><span class="line">		&#123;</span><br><span class="line">			return _con.pop_front();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	private:</span><br><span class="line">		Con _con;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>



<p>演示：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201147143.png"></p>
<hr>
<p>提一个问题，要不要写构造函数？</p>
<p>上面的stack和queue都没有写，这是为什么？</p>
<blockquote>
<p>因为其底层本质是借助容器适配器，在调用的时候容器适配器会完成构造，这里将没写</p>
</blockquote>
<hr>
<h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><p>这个名看着挺陌生的，但可以这么理解，这个所谓的优先级_队列，其实就是一个二叉堆，为什么这么说，可以看下面的部分。</p>
<hr>
<h2 id="priority-queue的介绍"><a href="#priority-queue的介绍" class="headerlink" title="priority_queue的介绍"></a>priority_queue的介绍</h2><p><a target="_blank" rel="noopener" href="https://m.cplusplus.com/reference/queue/priority_queue/" title="priority_queue - C++ Reference (cplusplus.com)">priority_queue - C++ Reference (cplusplus.com)</a></p>
<p>翻译一下，就是；</p>
<blockquote>
<ol>
<li>优先队列是一种容器适配器，根据严格的弱排序标准，它的第一个元素总是它所包含的元素中最大的。</li>
<li>此上下文类似于堆，在堆中可以随时插入元素，并且只能检索最大堆元素(优先队列中位于顶部的元素)。</li>
<li>优先队列被实现为容器适配器，容器适配器即将特定容器类封装作为其底层容器类，queue提供一组特定的成员函数来访问其元素。元素从特定容器的“尾部”弹出，其称为优先队列的顶部。</li>
<li>底层容器可以是任何标准容器类模板，也可以是其他特定设计的容器类。容器应该可以通过随机访问迭代器访问，并支持以下操作：</li>
</ol>
<p>empty()：检测容器是否为空</p>
<p>size()：返回容器中有效元素个数</p>
<p>front()：返回容器中第一个元素的引用</p>
<p>push_back()：在容器尾部插入元素</p>
<p>pop_back()：删除容器尾部元素</p>
<ol start="5">
<li>标准容器类vector和deque满足这些需求。默认情况下，如果没有为特定的priority_queue类实例化指定容器类，则使用vector。</li>
<li>需要支持随机访问迭代器，以便始终在内部保持堆结构。容器适配器通过在需要时自动调用算法函数make_heap、push_heap和pop_heap来自动完成此操作</li>
</ol>
</blockquote>
<p>其实看着一大堆，简化一下意思就是：</p>
<blockquote>
<p>这是一个由vector或者deque完成的一个容器，里面有一块连续空间来存放数据，为什么不能用list，因为它要完成调整，平时第一个元素是这块连续空间最大的（或者最小的），所以每插入一个元素都要调整，这么看，像不像之前学的堆？</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_60306111/article/details/123940534?spm=1001.2014.3001.5501" title="【数据结构】实现堆、堆的应用_Knous的博客-CSDN博客">【数据结构】实现堆、堆的应用_Knous的博客-CSDN博客</a></p>
<p>堆我也写了介绍，这里有兴趣的可以去看看，我们模拟实现其实思路跟那个差不多</p>
<h2 id="priority-queue的使用"><a href="#priority-queue的使用" class="headerlink" title="priority_queue的使用"></a>priority_queue的使用</h2><table>
<thead>
<tr>
<th>函数声明</th>
<th>接口说明</th>
</tr>
</thead>
<tbody><tr>
<td>priority_queue()&#x2F;priority_queue(first,</td>
<td></td>
</tr>
<tr>
<td>last)</td>
<td>构造一个空的优先级队列</td>
</tr>
<tr>
<td>empty( )</td>
<td>检测优先级队列是否为空，是返回true，否则返回</td>
</tr>
<tr>
<td>false</td>
<td></td>
</tr>
<tr>
<td>top( )</td>
<td>返回优先级队列中最大(最小元素)，即堆顶元素</td>
</tr>
<tr>
<td>push(x)</td>
<td>在优先级队列中插入元素x</td>
</tr>
<tr>
<td>pop()</td>
<td>删除优先级队列中最大(最小)元素，即堆顶元素</td>
</tr>
</tbody></table>
<p>这里要注意的不多，只有一个点，默认建立的是大堆，如果是小堆，需要传一个仿函数进去，这里演示的时候多了一个头文件：</p>
<p>functional</p>
<p>这个其实算一个算法的头文件</p>
<p>接下来看一下效果<img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201147499.png"></p>
<p>其实这就是堆排序了，每次都取最大的，依次取到最小的，所以是降序，如果要按照升序，那就要传一个greater过去：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201148508.png"></p>
<p>这个所谓的仿函数是什么？</p>
<p>你看完模拟实现就知道了</p>
<h2 id="priority-queue的模拟实现"><a href="#priority-queue的模拟实现" class="headerlink" title="priority_queue的模拟实现"></a>priority_queue的模拟实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T,class Con = deque&lt;T&gt;&gt;</span><br><span class="line">	class priority</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	private:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		Con _con;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>



<p>暂且只有这么多东西，一点一点来，首先写一个尾插看看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void push(const T&amp; val)</span><br><span class="line">		&#123;</span><br><span class="line">			_con.push_back(val);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<p>这样写，对吗？</p>
<p>如果是这样写的话，那跟stack、queue有什么区别吗？</p>
<blockquote>
<p>我们知道堆最大的特点就是它的最开头的元素是最大的（或者是最小的），为了实现这个特点，我们每插入一个数据的时候都要考虑它是否需要调整，这里就要写一个函数来完成，因为是从最后一个位置向上调，所以这个函数暂且就叫adjustup</p>
</blockquote>
<h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void push(const T&amp; val)</span><br><span class="line">		&#123;</span><br><span class="line">			_con.push_back(val);</span><br><span class="line">			AdjustUp(_con.size()-1);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void AdjustUp(int child)</span><br><span class="line">		&#123;</span><br><span class="line">			size_t parent = (child - 1) / 2;</span><br><span class="line">			while (child &gt; 0)</span><br><span class="line">			&#123;</span><br><span class="line">				if (_con[parent] &lt; _con[child])</span><br><span class="line">				&#123;</span><br><span class="line">					swap(_con[parent], _con[child]);</span><br><span class="line">					child = parent;</span><br><span class="line">					parent = (child - 1) / 2;</span><br><span class="line">				&#125;</span><br><span class="line">				else</span><br><span class="line">					break;</span><br><span class="line">			&#125;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p>所谓的删除，其实就是将开头位置的数据跟最后一个交换，然后再让size–，不过这里还有一个问题就是，最后一个元素其实是叶子节点，让叶子节点到了头节点上面，这就不符合堆的性质了，所以这里还要再写一个调整函数，因为是向下调整，所以这个就取名adjustdown</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void pop()</span><br><span class="line">		&#123;</span><br><span class="line">			if (_con.empty())</span><br><span class="line">				return;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				swap(_con.front(), _con.back());</span><br><span class="line">				_con.pop();</span><br><span class="line">				AdjustDown(0);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void AdjustDown(int praent)</span><br><span class="line">		&#123;</span><br><span class="line">			size_t child = praent * 2 + 1;</span><br><span class="line">			while (child &lt; _con.size())</span><br><span class="line">			&#123;</span><br><span class="line">				if (child + 1 &lt; _con.size() &amp;&amp; _con[child+1] &gt; _con[child])</span><br><span class="line">				&#123;</span><br><span class="line">					child += 1;</span><br><span class="line">				&#125;</span><br><span class="line">				if (_con[praent] &lt; _con[child])</span><br><span class="line">				&#123;</span><br><span class="line">					swap(_con[praent], _con[child]);</span><br><span class="line">					praent = child;</span><br><span class="line">					child = praent * 2 + 1;</span><br><span class="line">				&#125;</span><br><span class="line">				else</span><br><span class="line">					break;</span><br><span class="line">			&#125;</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<h3 id="容量、是否为空、顶端元素"><a href="#容量、是否为空、顶端元素" class="headerlink" title="容量、是否为空、顶端元素"></a>容量、是否为空、顶端元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">size_t size()</span><br><span class="line">		&#123;</span><br><span class="line">			return _con.size();</span><br><span class="line">		&#125;</span><br><span class="line">bool empty()</span><br><span class="line">		&#123;</span><br><span class="line">			return _con.empty();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">const T&amp; top()</span><br><span class="line">		&#123;</span><br><span class="line">			return _con[0];</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<h3 id="用迭代器区间来构造"><a href="#用迭代器区间来构造" class="headerlink" title="用迭代器区间来构造"></a>用迭代器区间来构造</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class Inputiterator&gt;</span><br><span class="line">		priority_queue(Inputiterator first, Inputiterator last)</span><br><span class="line">		&#123;</span><br><span class="line">			while (first != last)</span><br><span class="line">			&#123;</span><br><span class="line">				push(*first);</span><br><span class="line">				first++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<p>其实跟之前写的迭代器区间没什么区别，先插入，然后调整</p>
<p>测试：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201148390.png"></p>
<p>没什么问题，但是又有点问题</p>
<p>就是，这个调整堆的部分是固定的，也就是说它只能单纯的是大堆或者是小堆，那么有没有办法可以解决这个问题呢？</p>
<p>当然有，这个比较函数不要定死就可以了，既然如此，就有了第三个模板参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">	struct less</span><br><span class="line">	&#123;</span><br><span class="line">		bool operatop(T&amp; x,T&amp; y) const</span><br><span class="line">		&#123;</span><br><span class="line">			return x &lt; y ? ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	template&lt;class T,class Con = deque&lt;T&gt;,class cmp = less&lt;T&gt;&gt;</span><br></pre></td></tr></table></figure>



<p>借此，我们写了一个新的类出来</p>
<p>这个类名字就叫less，里面没有参数，只有一个运算符的重载，我们默认传过去的是less，到时候比较的时候我们就可以靠cmp来比较，然后判断交换</p>
<p>经过修改后的比较函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void AdjustUp(int child)</span><br><span class="line">		&#123;</span><br><span class="line">			size_t parent = (child - 1) / 2;</span><br><span class="line">			while (child &gt; 0)</span><br><span class="line">			&#123;</span><br><span class="line">				if (cmp(_con[parent] , _con[child]))</span><br><span class="line">				&#123;</span><br><span class="line">					swap(_con[parent], _con[child]);</span><br><span class="line">					child = parent;</span><br><span class="line">					parent = (child - 1) / 2;</span><br><span class="line">				&#125;</span><br><span class="line">				else</span><br><span class="line">					break;</span><br><span class="line">			&#125;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		void AdjustDown(int praent)</span><br><span class="line">		&#123;</span><br><span class="line">			size_t child = praent * 2 + 1;</span><br><span class="line">			while (child &lt; _con.size())</span><br><span class="line">			&#123;</span><br><span class="line">				if (child + 1 &lt; _con.size() &amp;&amp; cmp(_con[child], _con[child+1]))</span><br><span class="line">				&#123;</span><br><span class="line">					child += 1;</span><br><span class="line">				&#125;</span><br><span class="line">				if (cmp(_con[praent], _con[child]))</span><br><span class="line">				&#123;</span><br><span class="line">					swap(_con[praent], _con[child]);</span><br><span class="line">					praent = child;</span><br><span class="line">					child = praent * 2 + 1;</span><br><span class="line">				&#125;</span><br><span class="line">				else</span><br><span class="line">					break;</span><br><span class="line">			&#125;</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<p>注意这里有一个坑，就是less其实就是一个类，作为一个类，它必须先创建一个对象出来，然后才能调用…</p>
<p>既然有了less，那就再写一个greater</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">	struct greater</span><br><span class="line">	&#123;</span><br><span class="line">		bool operator()(const T&amp; x, const T&amp;  y) const</span><br><span class="line">		&#123;</span><br><span class="line">			return x &gt; y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>



<p>既然我们要调用这个greater，那就应该先传过去vector，如图：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201148810.png"></p>
<p>那这个greater是什么？</p>
<p>其实这就是一个仿函数，这里就简单说一下，这里当然也可以用函数指针来代替，但却过于繁琐，不如我们直接重载一个括号比较，如果有兴趣可以看这篇博客</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/K346K346/article/details/82818801" title="C++ 仿函数_恋喵大鲤鱼的博客-CSDN博客_c++仿函数">C++ 仿函数_恋喵大鲤鱼的博客-CSDN博客_c++仿函数</a></p>
<p>至此，stack和queue的模拟实现也已经完成，希望这篇文章对你的学习有所帮助</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://example.com/2022/07/15/stack%E3%80%81queue%E3%80%81priority_queue/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://example.com/2022/07/15/stack%E3%80%81queue%E3%80%81priority_queue/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
