<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Knous">
    
    <title>
        
            堆 |
        
        Knous
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/avatar.png">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.png","favicon":"/images/avatar.png","article_img_align":"center","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/images/welcome.jpg","description":"Welcome"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Knous
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                TAGS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">TAGS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">堆</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Knous</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-04-23 00:00:00</span>
        <span class="mobile">2022-04-23 00:00</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <hr>
<p><strong>1.插入排序</strong></p>
<p><strong>2.希尔排序</strong></p>
<p><strong>3.选择排序</strong></p>
<p><strong>4.堆排序</strong></p>
<p><strong>5.冒泡排序</strong></p>
<p><strong>6.快速排序</strong></p>
<p><strong>7.归并排序</strong></p>
<p><strong>8.计数排序</strong></p>
<hr>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>这个排序原来很简单，如图演示：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200932305.png"></p>
<p>我们先把 9 看作有序数组插入，它比8大，那就交换位置</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200932128.png"></p>
<p>此时，8前面没有数字了，所以它就停下，再把8 9 看作有序数组：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200932900.png"></p>
<p>再把 7 插入，因为9比7大，交换，8比7大，交换，就是这样：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200932118.png"></p>
<p>重复这样的步骤，直到数组结&#x2F;或者已经交换完全</p>
<p>实现代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 插入排序</span><br><span class="line">void InsertSort(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">    //因为tmp是当前下标的后一个元素比较，所以最后一个元素的位置是n-1</span><br><span class="line">	for (int i = 0; i &lt; n-1; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int n = i;</span><br><span class="line">		int tmp = a[1 + n];</span><br><span class="line">        //假设每次都要比到最后</span><br><span class="line">		while (n &gt;= 0)</span><br><span class="line">		&#123;</span><br><span class="line">            //如果小于，就让这个位置元素被替代，然后再跟前一个比较</span><br><span class="line">			if (tmp &lt; a[n])</span><br><span class="line">			&#123;</span><br><span class="line">				a[n + 1] = a[n];</span><br><span class="line">				n -= 1;</span><br><span class="line">			&#125;</span><br><span class="line">            //如果不小，那就退出</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        //它停下的位置就是前面已经没有比它小的元素了，但是因为上面替换之前-1，所以这里要+1</span><br><span class="line">		a[n + 1] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>时间复杂度：最好O（N^2）,最坏O（N^2）,因为它总要比较判断</strong></p>
<p><strong>空间复杂度：O（1），没有额外开辟空间</strong></p>
<p>时间太慢了，不是很推荐</p>
<hr>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a><strong>希尔排序</strong></h2><p>插入排序属实太慢了，假设一个很小的元素在最后面，那它要移动N次才能来到前面的位置（1在最后面，它要来到9的位置就要换8次）</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200932406.png"></p>
<p>所以它的改进版本，希尔排序就出来了，希尔排序是这么想的，有一个间隔数gap，这个数可以很大，也可以很小，它先将数组分为几个小组：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200932115.png"></p>
<p>红色一组为：9 6 3</p>
<p>蓝色一组为：8 5 2</p>
<p>绿色一组为：7 4 1</p>
<p>我这里设置的gap是3，应该可以看的出来，然后分别对这几个小组排序：</p>
<p>9 6 3 变成 3 6 9</p>
<p>8 5 2 变成 2 5 8</p>
<p>7 4 1 变成 1 4 7</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200932778.png"></p>
<p>就变成这样，这里只是举例子，因为降序方便看就设置为这样，实际要混乱一点，然后再对这降序的再排一次（这里已经有序了就没画）</p>
<p><strong>每一次排序都会让数组更加有序</strong></p>
<p><strong>如果这个gap很大，那小的数组会更快的来到前面，因为它一次可以跳gap格，大的也会更快的去到后面</strong></p>
<p><strong>如过这个gap很小，那它每次移动都会给更加有序，如果是1，那就跟插入排序一样了</strong></p>
<p><strong>这个gap肯定不能太小，并且不能是固定的数字，如果是固定的数字，那它每次移动就会很慢，所以最好跟N扯上关系，如果看懂了插入排序，那希尔就很好理解，它不过是把 n+1 变成了 n+gap，然后再插入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 希尔排序</span><br><span class="line">void ShellSort(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">    //定义一个gap</span><br><span class="line">	int gap = n;</span><br><span class="line">	while (gap &gt; 1)</span><br><span class="line">	&#123;</span><br><span class="line">        //这个值就是间隔</span><br><span class="line">		gap = gap / 3 + 1;</span><br><span class="line">        //每次都是跟 n+gap比较，所以最后一个比较元素的位置是n-gap</span><br><span class="line">		for (int i = 0; i &lt; n - gap; i++)</span><br><span class="line">		&#123;</span><br><span class="line">            //从这个下标开始，如果直接拿i的话会死循环</span><br><span class="line">			int n = i;</span><br><span class="line">			int tmp = a[n + gap];</span><br><span class="line">            //如果这个n&gt;0,那它前面还有没比较的值</span><br><span class="line">			while (n &gt;= 0)</span><br><span class="line">			&#123;</span><br><span class="line">                //比较</span><br><span class="line">				if (tmp &lt; a[n])</span><br><span class="line">				&#123;</span><br><span class="line">                    //交换，并且让n-gap，找到下一个间隔为gap的比较</span><br><span class="line">					a[n + gap] = a[n];</span><br><span class="line">					n -= gap;</span><br><span class="line">				&#125;</span><br><span class="line">				else</span><br><span class="line">				&#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            //同理，最后一次这个n肯定被-gap，所以加上</span><br><span class="line">			a[n+gap] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>*<em>时间复杂度： O (n <em>logn)</em></em></p>
<p><strong>空间复杂度：O（1）</strong></p>
<p>这个算法非常快，建议使用</p>
<hr>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><strong>选择排序</strong></h2><p><strong>最好理解的排序，每次找最大的（或者最小的），也可以一起找出来，然后跟第一个元素和最后一个元素换位置，换完就排完了</strong></p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200933104.png"></p>
<p>然后交换，找出次大的，次小的：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200933050.png"></p>
<p>循环即可 ，但是一定要注意，因为这里一次交换两个值，所以可能出现：</p>
<p><strong>原本最大值的下标是0，然后最小值的下标是3，最小值先跟0的位置换，这个最大值就被交换到3的位置去了，再去交换下标0就会找到最小值，所以先判断交换位置有没有冲突，有就调整</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 选择排序</span><br><span class="line">void SelectSort(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">    //要交换的左右下标</span><br><span class="line">	int left = 0, right = n - 1;</span><br><span class="line">	while (left &lt; right)</span><br><span class="line">	&#123;</span><br><span class="line">        //找出数组里面最大值和最小值的下标</span><br><span class="line">		int max, min;</span><br><span class="line">		max = min = left;</span><br><span class="line">		for (int i = left+1; i &lt;= right; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (a[i] &gt; a[max])</span><br><span class="line">			&#123;</span><br><span class="line">				max = i;</span><br><span class="line">			&#125;</span><br><span class="line">			if (a[i] &lt; a[min])</span><br><span class="line">			&#123;</span><br><span class="line">				min = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        //交换</span><br><span class="line">		swap(&amp;a[left], &amp;a[min]);</span><br><span class="line">        //如果最大值的下标是上面的left，那它就会被交换到min的位置，所以让max指向被交换后的位置</span><br><span class="line">		if (max == left)</span><br><span class="line">		&#123;</span><br><span class="line">			max = min;</span><br><span class="line">		&#125;</span><br><span class="line">        //再次交换</span><br><span class="line">		swap(&amp;a[right], &amp;a[max]);</span><br><span class="line">        //再换下一组</span><br><span class="line">		left++;</span><br><span class="line">		right--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>时间复杂度：最好O（N^2）,最坏O（N^2），因为不管怎么样它都要查找然后交换</strong></p>
<p><strong>空间复杂度：O（1），没有额外开辟空间</strong></p>
<p><strong>不是很快，不推荐使用</strong></p>
<p><strong>———–</strong></p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>这个在我以前专栏里面有详细说过，如果不了解堆的性质可以去看看，这里简单描述一下：</p>
<p><strong>一个堆的堆顶是数组里面的最大值，那它就是大堆</strong></p>
<p><strong>一个堆的堆顶是数组里面的最小值，那它就是小堆</strong></p>
<p><strong>假设我们是升序，那我们就要建立大堆（降序建小堆），然后把堆顶的元素（也就是下标为0的元素）跟最后一个元素换，然后再调整一下堆即可</strong></p>
<p>这里我就直接上代码实现了：</p>
<p>先是建立大堆的调整函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void AdjustDown(int* arr, int* root, int* end)</span><br><span class="line">&#123;</span><br><span class="line">    //父亲节点</span><br><span class="line">	int parent = root;</span><br><span class="line">    //孩子节点</span><br><span class="line">	int child = parent * 2+1;</span><br><span class="line">	while (child &lt; end)</span><br><span class="line">	&#123;</span><br><span class="line">        //选两个孩子里面大的那个</span><br><span class="line">		if (arr[child + 1] &gt; arr[child] &amp;&amp; (child+1) &lt;end)</span><br><span class="line">		&#123;</span><br><span class="line">			child++;</span><br><span class="line">		&#125;</span><br><span class="line">        //如果父亲比孩子小，交换</span><br><span class="line">		if (arr[parent] &lt; arr[child])</span><br><span class="line">		&#123;</span><br><span class="line">			swap(&amp;arr[parent], &amp;arr[child]);</span><br><span class="line">			parent = child;</span><br><span class="line">			child = parent * 2 + 1;</span><br><span class="line">		&#125;</span><br><span class="line">        //不小就跳出</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后是排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 堆排序</span><br><span class="line">void HeapSort(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">        //先建立一个大堆</span><br><span class="line">		for (int i = (n - 2)/2; i &gt;= 0; --i)</span><br><span class="line">		&#123;</span><br><span class="line">			AdjustDown(a, i, n);</span><br><span class="line">		&#125;</span><br><span class="line">        //最后一个元素的下标，交换使用</span><br><span class="line">		int end = n - 1;</span><br><span class="line">		while (end)</span><br><span class="line">		&#123;</span><br><span class="line">            //将最大的放到最后</span><br><span class="line">			swap(&amp;a[end], &amp;a[0]);</span><br><span class="line">            //重新调整堆</span><br><span class="line">			AdjustDown(a, 0, end);</span><br><span class="line">            //最后位置就不用排了</span><br><span class="line">            end--;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>*<em>时间复杂度： O (n <em>logn)</em></em></p>
<p><strong>空间复杂度：O（1）</strong></p>
<p>这个算法跟希尔排序一个级别，除了代码比较多以外，还是很推荐的</p>
<hr>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>老朋友了，我相信这个我不说大家也明白，具体思路是：</p>
<p>如果前面一个大于后面一个，交换，然后遍历数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 冒泡排序</span><br><span class="line">void BubbleSort(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int j = 0; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (a[j - 1] &gt; a[j])</span><br><span class="line">			&#123;</span><br><span class="line">				swap(&amp;a[j - 1], &amp;a[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>就不写注释了，实在太简单了</p>
<p><strong>时间复杂度：O（N^2）</strong></p>
<p><strong>空间复杂度：O（N）</strong></p>
<p>不推荐使用，太慢了，太慢了，太慢了！！！</p>
<p>如果代码没问题但时间超时，多半是它的锅，别用</p>
<hr>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>这个不是那个qsort，但也挺快的</strong></p>
<p>有好几种思路，先说第一种：</p>
<h3 id="1、hoare版："><a href="#1、hoare版：" class="headerlink" title="1、hoare版："></a><strong>1、hoare版：</strong></h3><p><strong>使用递归，看图演示：</strong></p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200933318.png"></p>
<p>假设这是要排序的数组，第一步，我们选一个数字作为Key，这里我选 6（第一个元素的位置） ，那我们就从6开始走，先走Key的另一边，如果我选左边，那就先走右边，选右边就先走左边：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200933613.png"></p>
<p>右边要找到比Key小的值，因为Key是6，这里2比6小，所以停下</p>
<p>然后找左边：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200933362.png"></p>
<p>左边找比Key大的值，5 4 都不符合条件，所以跳过，9比6大，所以停下，然后我们交换位置：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200933842.png"></p>
<p>然后右边再继续先走，找到比6小的：，左边找比6大的</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200933565.png"></p>
<p>右边停在1，左边停在8，停下再次交换：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200933891.png"></p>
<p>此时右边再开始走：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200933302.png"></p>
<p>它们相遇了，这个时候我们就把这个位置的值跟Key（第一个元素的位置交换）：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200933764.png"></p>
<p>到这里，第一次就走完了，我们发现比Key小的都在左边，比Key大的都在右边，而6也来到了正确的位置，它的左边都比它小，它的右边都比它大</p>
<p>然后我们将数组分割：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200933328.png"></p>
<p>在这两个数组里面重复上面的步骤，直到它们不可再分割为止：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200933429.png"></p>
<p>第一次分割将数组分为两半，第二次将左边长的一段又变成两段…</p>
<p>看看代码理解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 单趟快排</span><br><span class="line">int PartSort(int* a, int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">    //先将left现在的值保留下来（一般是0）</span><br><span class="line">	int keyi = left;</span><br><span class="line">    //如果左边大于右边那肯定相遇了</span><br><span class="line">	while (left &lt; right)</span><br><span class="line">	&#123;</span><br><span class="line">		// 找小</span><br><span class="line">		while (left &lt; right &amp;&amp; a[right] &gt;= a[keyi])</span><br><span class="line">			--right;</span><br><span class="line"></span><br><span class="line">		// 找大</span><br><span class="line">		while (left &lt; right &amp;&amp; a[left] &lt;= a[keyi])</span><br><span class="line">			++left;</span><br><span class="line">        </span><br><span class="line">        //交换</span><br><span class="line">		swap(&amp;a[left], &amp;a[right]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    //出来了就是相遇，这里的元素跟Key交换</span><br><span class="line">	swap(&amp;a[keyi], &amp;a[left]);</span><br><span class="line"></span><br><span class="line">    //返回中间的节点，将其分割为两段</span><br><span class="line">	return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是一趟，我们递归调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void QuickSort(int* a, int begin, int end)</span><br><span class="line">&#123;</span><br><span class="line">	// 如果起始位址等于（或者大于）终点为止，那就可以返回了</span><br><span class="line">	if (begin &gt;= end)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    //这个值就是中点</span><br><span class="line">	int keyi = PartSort(a, begin, end);</span><br><span class="line">	</span><br><span class="line">    //左半边，因为Key已经到了正确的为止，所以不用排了，left通常是0</span><br><span class="line">	QuickSort(a, begin, keyi - 1);</span><br><span class="line">       </span><br><span class="line">    //右边，Key不排，结束为止就是end（数组长度）</span><br><span class="line">	QuickSort(a, keyi + 1, end);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、挖坑法"><a href="#2、挖坑法" class="headerlink" title="2、挖坑法"></a>2、挖坑法</h3><p>这种思路是这么的：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200933759.png"></p>
<p>假设现在有这么一组数据，将最左边这个 6 保存下来，并让一个值指向这里，我们称之为pit（坑位）。</p>
<p>程序开始走，因为坑位在左边，所以要从右边开始走，right 从 7 开始，它的目标是找到比 6 小的数字：</p>
<p>7 &lt; 6 ?</p>
<p>8 &lt; 6 ?</p>
<p>9 &lt; 6 ?</p>
<p>1 &lt; 6 ?</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200934990.png"></p>
<p>它就停下来了 ，此时它指向 1 ，1 &lt; 6</p>
<p>找到了小，我们就让 1 放到坑位里面，坑位就是这里的 6 ：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200934583.png"></p>
<p>此时，因为坑位到了右边，下一次就要从左边开始走，left 从 5 开始，找比 6 大的：</p>
<p>5 &lt; 6 ?</p>
<p>4 &lt; 6 ?</p>
<p>3 &lt; 6 ?</p>
<p>2 &lt;6 ?</p>
<p>1 &lt; 6 ?</p>
<p>此时 left 来到 right 的位置，它们重叠了，而这里正好是 1 的位置，将一开始保存的 6 放到这里：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200934325.png"></p>
<p>一趟排序就完成了，左边都是比 tmp（6） 小的，右边都是比它大的，随后我们递归调用即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 快速排序挖坑法</span><br><span class="line">int PartSort2(int* a, int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">    //坑位</span><br><span class="line">	int pit = left;</span><br><span class="line">    //key</span><br><span class="line">	int key = a[left];</span><br><span class="line">    //一趟走N次</span><br><span class="line">	while (left &lt; right)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">        //找小</span><br><span class="line">		while (a[right] &gt; key &amp;&amp; left &lt; right)</span><br><span class="line">		&#123;</span><br><span class="line">			right--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        //将找到的小放到坑里面，然后将这里变成新的坑</span><br><span class="line">		a[pit] = a[right];</span><br><span class="line">		pit = right;</span><br><span class="line"></span><br><span class="line">        //找大</span><br><span class="line">		while (a[left] &lt; key &amp;&amp; left &lt; right)</span><br><span class="line">		&#123;</span><br><span class="line">			left++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">       //将找到的大放到坑里面，然后将这里变成新的坑</span><br><span class="line">		a[pit] = a[left];</span><br><span class="line">		pit = left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    //它们相遇的位置，就是key的位置</span><br><span class="line">	a[left] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="3、前后指针法"><a href="#3、前后指针法" class="headerlink" title="3、前后指针法"></a>3、前后指针法</h3><p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200934791.png"></p>
<p>第一个指针指向 6</p>
<p>第二个指针指向 5</p>
<p>key 是第一个元素 6</p>
<p>如果 cur 位置的元素大于 key 并且  ++prev 的位置不等于 cur ，那就交换：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200934838.png"></p>
<p>5 &lt; 6 ? cur++;</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200934906.png"></p>
<p>4 &lt; 5 ?   ++prev &#x3D;&#x3D; cur ?</p>
<p>交换它们的值：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200934121.png"></p>
<p>cur++;</p>
<p>3 &lt; 6 ? ++prev &#x3D;&#x3D; cur?</p>
<p>再次交换：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200934925.png"></p>
<p>cur++；</p>
<p>…..</p>
<p>直到：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200934668.png"></p>
<p>此时，cur处元素大于key，所以不执行交换，但是cur++</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200934521.png"></p>
<p>cur 大于 key</p>
<p>cur++</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200934209.png"></p>
<p>cur 大于 key</p>
<p>cur++</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200934137.png"></p>
<p>此时cur越界，所以循环停下，将prev的值跟key的值交换：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200934065.png"></p>
<p>第一趟结束</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 快速排序前后指针法</span><br><span class="line">int PartSort3(int* a, int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">    //前、后指针</span><br><span class="line">	int prev = left;</span><br><span class="line">	int cur = prev + 1;</span><br><span class="line">    //key的值</span><br><span class="line">	int key = left;</span><br><span class="line">	while (cur &lt;= right)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">        //开始走</span><br><span class="line">		if (a[cur] &lt; a[key] &amp;&amp; a[++prev] != a[cur])</span><br><span class="line">		&#123;</span><br><span class="line">			swap(&amp;a[prev], &amp;a[cur]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        //每次cur都++</span><br><span class="line">		cur++;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    //交换</span><br><span class="line">	swap(&amp;a[prev], &amp;a[key]);</span><br><span class="line"></span><br><span class="line">	return prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="如何优化快排"><a href="#如何优化快排" class="headerlink" title="如何优化快排"></a>如何优化快排</h3><p><strong>小区间优化：</strong></p>
<p>但看快排的代码，它是靠递归完成的，这样的一个好处是可以把一个很麻烦的问题分成小问题解决</p>
<p>但是缺点同样很明显，假设这一次只要排 4 个数据，你还分成好几个小块，就有点太麻烦了，所以我们可以在快排里面调用一下 插入排序，当要排序的小于一定个数时，就不递归了，直接排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void QuickSort(int* a, int begin, int end)</span><br><span class="line">&#123;</span><br><span class="line">	// 如果起始位址等于（或者大于）终点为止，那就可以返回了</span><br><span class="line">	if (begin &gt;= end)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	//小于13个就插入，这个区间可以自己定</span><br><span class="line">	if (end - begin + 1 &lt; 13)</span><br><span class="line">	&#123;</span><br><span class="line">		InsertSort(a, end - begin + 1);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//这个值就是中点</span><br><span class="line">	int keyi = PartSort3(a, begin, end);</span><br><span class="line"></span><br><span class="line">	//左半边，因为Key已经到了正确的为止，所以不用排了，left通常是0</span><br><span class="line">	QuickSort(a, begin, keyi - 1);</span><br><span class="line"></span><br><span class="line">	//右边，Key不排，结束为止就是end（数组长度）</span><br><span class="line">	QuickSort(a, keyi + 1, end);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>选择优化</strong></p>
<p>另外，还有一个可以优化的地方，如果每次快排的 key 都是数组中间的数，那它的时间复杂度是</p>
<p>N*logN，那它的最坏情况呢？</p>
<p>如果每次都选到两边的数据，那它的时间复杂度毫无疑问的是 N^2,针对这种情况，我们还可以优化一个函数，确保key不是数组两边的数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">int FindKey(int* a, int left,int right)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	int key = left + (left + right) / 2;</span><br><span class="line">	if (a[left] &lt; a[key])</span><br><span class="line">	&#123;</span><br><span class="line">		if (a[right] &gt; a[key])</span><br><span class="line">		&#123;</span><br><span class="line">			return key;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (a[left] &gt; a[right])</span><br><span class="line">		&#123;</span><br><span class="line">			return left;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			return right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		if (a[key] &gt; a[right])</span><br><span class="line">		&#123;</span><br><span class="line">			return key;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (a[left] &lt; a[right])</span><br><span class="line">		&#123;</span><br><span class="line">			return left;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			return right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看着复杂，不过不算难，再将用到Key的地方全部换成这个函数优化key的选择，快排还能还进一步…</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>非递归实现</p>
<p>如何实现非递归？</p>
<p>那我们就要好好想想递归是来做什么的：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200934196.png"></p>
<p>这是要排序的数组，快排递归实现就是如下图所示：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200934441.png"></p>
<p>它会将选定的key排到它应该有的位置，而 左边都比它小，右边都比它大，随后，它将key左边传入函数，再递归，再将右边传入函数递归：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200934799.png"></p>
<p>每一次，它都至少可以保证一个数字来到应该有的位置上，如此反复</p>
<p>…</p>
<p>如果要非递归，那我们就要实现的是每一次都传入一个区间，直到每个区间都覆盖到，这里就要用到之前的 队列&#x2F;栈</p>
<p>我这里用的是栈， 在用之前，要先把栈的函数拷贝一份：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">void StackInit(Stack* ps)</span><br><span class="line">&#123;</span><br><span class="line">	assert(ps);</span><br><span class="line">	ps-&gt;arr = NULL;</span><br><span class="line">	ps-&gt;capacity = 0;</span><br><span class="line">	ps-&gt;top = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void StackPush(Stack* ps, STDataType data)</span><br><span class="line">&#123;</span><br><span class="line">	assert(ps);</span><br><span class="line">	if (ps-&gt;top == ps-&gt;capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		int newcapacity = ps-&gt;capacity == 0 ? 4 : (ps-&gt;capacity) * 2;</span><br><span class="line">		ps-&gt;arr = (STDataType*)realloc(ps-&gt;arr, sizeof(Stack)* newcapacity);</span><br><span class="line">		if (ps-&gt;arr == NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;realloc fail\n&quot;);</span><br><span class="line">			exit(-1);</span><br><span class="line">		&#125;</span><br><span class="line">		ps-&gt;capacity = newcapacity;</span><br><span class="line">	&#125;</span><br><span class="line">	ps-&gt;arr[ps-&gt;top++] = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void StackPop(Stack* ps)</span><br><span class="line">&#123;</span><br><span class="line">	assert(ps);</span><br><span class="line">	assert(ps-&gt;top &gt; 0);</span><br><span class="line">	ps-&gt;top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">STDataType StackTop(Stack* ps)</span><br><span class="line">&#123;</span><br><span class="line">	assert(ps);</span><br><span class="line">	return ps-&gt;arr[ps-&gt;top-1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int StackSize(Stack* ps)</span><br><span class="line">&#123;</span><br><span class="line">	assert(ps);</span><br><span class="line">	return ps-&gt;top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int StackEmpty(Stack* ps)</span><br><span class="line">&#123;</span><br><span class="line">	assert(ps);</span><br><span class="line">	return ps-&gt;top == 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void StackDestroy(Stack* ps)</span><br><span class="line">&#123;</span><br><span class="line">	assert(ps);</span><br><span class="line">	free(ps-&gt;arr);</span><br><span class="line">	ps-&gt;arr = NULL;</span><br><span class="line">	ps-&gt;top = 0;</span><br><span class="line">	ps-&gt;capacity = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>都是之前写过也用过好几次的代码了，这里就不重复说明了</p>
<p>思路是这样的：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200934542.png"></p>
<p>已有一个数组，将它最左边的和最右边的下标压下去</p>
<p>这里压的是 6 和 8</p>
<p>循环判断，如果栈不为空，就进去</p>
<p>随后拿两个值来接收栈里面的值，一个是左下标，一个是右下标，对这一块空间排序</p>
<p>然后对它进行一次排序，随后它应该会被分成两块：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200935482.png"></p>
<p>可以看到key左边是一块待排序的空间，右边也是一块待排序的空间</p>
<p>将它的左边压栈，它左边的空间是 0 - key-1</p>
<p>将它的右边压栈，它右边的空间是 key+1 - end（数组末尾）</p>
<p>不过在压栈之前，最好先判断一下它们中间有没有数据</p>
<p>如果此时数组还没排完，那栈里面应该还压着其他区间，随后再次读取数据</p>
<p>直到栈为空</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void QuickSortNonR(int* a, int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">    //创建栈并初始化</span><br><span class="line">	Stack st;</span><br><span class="line">	StackInit(&amp;st);</span><br><span class="line">    </span><br><span class="line">    //插入头尾</span><br><span class="line">	StackPush(&amp;st, left);</span><br><span class="line">	StackPush(&amp;st, right);</span><br><span class="line"></span><br><span class="line">    //循环代替递归</span><br><span class="line">	while (!StackEmpty(&amp;st))</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">        //因为后压的右下标，所以右下标先出来</span><br><span class="line">		int right1 = StackTop(&amp;st);</span><br><span class="line">		StackPop(&amp;st);</span><br><span class="line">		int left1 = StackTop(&amp;st);</span><br><span class="line">		StackPop(&amp;st);</span><br><span class="line"></span><br><span class="line">        //对这一块空间排序</span><br><span class="line">		int mid = PartSort2(a, left1, right1);</span><br><span class="line"></span><br><span class="line">        //如果左边还有就压左边</span><br><span class="line">		if (mid-1-left1&gt;0)</span><br><span class="line">		&#123;</span><br><span class="line">			StackPush(&amp;st, left1);</span><br><span class="line">			StackPush(&amp;st, mid - 1);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        //右边还有就压右边</span><br><span class="line">		if (right1-mid-1&gt;0)</span><br><span class="line">		&#123;</span><br><span class="line">			StackPush(&amp;st, mid + 1);</span><br><span class="line">			StackPush(&amp;st, right1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    //排序完销毁栈</span><br><span class="line">	StackDestroy(&amp;st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里用的单趟快排上面可以复制，这里将不写了.</p>
<p><strong>时间复杂度：O（N*logN）</strong></p>
<p><strong>空间复杂度：O（1）</strong></p>
<p><strong>挺快的，但代码很长…</strong></p>
<hr>
<h2 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h2><p>如果做过这样的一道题，那归并的思路就很好理解了：</p>
<p>请合并两个有序数组，并让返回的数组依旧有序</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200935351.png"></p>
<p>先比较第一个数据</p>
<p>1 &gt;  2  ?</p>
<p>新创建的数组的第一个元素就放小的那个，然后让 3 跟  2  比</p>
<p>2 小于 3</p>
<p>所以新数组第二个元素就放 2</p>
<p>然后 4 跟  3  比</p>
<p>…….</p>
<p>直到其中一个没有或者两个都比完：</p>
<p>这就叫归并</p>
<p>那归并排序是什么样的呢？</p>
<p>看图：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200935212.png"></p>
<p>这是已有的数组</p>
<p>对其中每一块区域分别归并：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200935488.png"></p>
<p>以左半边举例</p>
<p>9  3  8  6 显然无序</p>
<p>将它分为9  3   一组 8   6</p>
<p>9  3 也无序，所以将其分为   9  一组，3一组</p>
<p>然后归并就变成了</p>
<p>3  9</p>
<p>8  6归并就成了6  8</p>
<p>再将3  9 和6  8归并</p>
<p>3  6  8  9</p>
<p>递归的条件，即有多个元素，每次都分一半，直到没得分，这个时候就可以归并了</p>
<p>切记，归并不能在原数组归并，不然会丢失数据，所以要新建立一个临时数组，然后将这个数组的值拷贝进去</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">void _MergeSort(int*a, int begin, int end, int* tmp)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //如果begin &gt;= end  说明这个区间是无效区间，直接返回</span><br><span class="line">	if (begin &gt;= end)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //每次都取一半</span><br><span class="line">	int mid = (begin + end) / 2;</span><br><span class="line"></span><br><span class="line">    //左半边</span><br><span class="line">	_MergeSort(a, 0, mid, tmp);</span><br><span class="line"></span><br><span class="line">    //右半边</span><br><span class="line">	_MergeSort(a, mid+1, end, tmp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //单趟（归并没什么好说的吧？）</span><br><span class="line">	int begin1 = begin ,  end1 = mid;</span><br><span class="line">	int begin2 = mid + 1, end2 = end;</span><br><span class="line">	int pos = begin;</span><br><span class="line"></span><br><span class="line">	while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)</span><br><span class="line">	&#123;</span><br><span class="line">		if (a[begin1] &lt; a[begin2])</span><br><span class="line">			tmp[pos++] = a[begin1++];</span><br><span class="line">		else</span><br><span class="line">			tmp[pos++] = a[begin2++];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    //也许是其中一个数组放完了，另一个还没有，所以判断一下</span><br><span class="line">	while (begin1 &lt;= end1)</span><br><span class="line">		tmp[pos++] = a[begin1++];</span><br><span class="line"></span><br><span class="line">	while (begin2 &lt;= end2)</span><br><span class="line">		tmp[pos++] = a[begin2++];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //别忘了拷贝过去</span><br><span class="line">	memcpy(a + begin, tmp + begin, (end - begin + 1)*sizeof(int));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 归并排序递归实现</span><br><span class="line">void MergeSort(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //新建立的临时数组，用于存放归并数组的数据</span><br><span class="line">	int* tmp = (int*)malloc(sizeof(int)* n);</span><br><span class="line">	assert(tmp);</span><br><span class="line"></span><br><span class="line">    //调用归并函数</span><br><span class="line">	_MergeSort(a, 0, n, tmp);</span><br><span class="line"></span><br><span class="line">	free(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>时间复杂度：O（N*logN）</strong></p>
<p><strong>空间复杂度：O（N）</strong></p>
<p><strong>不好用，别用</strong></p>
<hr>
<h3 id="非递归实现归并"><a href="#非递归实现归并" class="headerlink" title="非递归实现归并"></a>非递归实现归并</h3><p>非递归，就是模拟递归的一个过程</p>
<p>在递归实现里面，先将其中元素一个一个归并，然后再两个两个归并，再四个四个归并…</p>
<p>那是不是可以拿一个循环解决？</p>
<p>所以，非递归版本就这么来了：</p>
<p>首先要定义一个gap，这个gap是每次递归的区间</p>
<p>如果是1，每次就归并一个</p>
<p>如果是2，每次就归并两个</p>
<p>如果是4，每次就归并四个</p>
<p>…</p>
<p>每次都归并一个数组的长度，可以嵌套一个for循环</p>
<p>在定义两个数组的头尾指针</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200935691.png"></p>
<p>如果gap是1，预期的效果是每次比较1个，那头尾指针就该这么定义：</p>
<p>begin1 &#x3D; 0，end1 &#x3D; begin1+gap-1；</p>
<p>begin1是从0开始的，如果循环比较，那这里应该赋值为i（循环）</p>
<p>end1 则是 begin1 加个gap（间隔），但是别忘了-1才是下标</p>
<p>begin2 则是 begin+gap，这样就跳过了begin1的数组</p>
<p>end2 则是 begin2+gap-1，同end1原理</p>
<p>…</p>
<p>在走过一遍之后，要将gap*2，这样就可以一次归并两个长度为2的数组</p>
<p>…</p>
<p><strong>切记</strong></p>
<p><strong>可能越界，因为gap每次乘2，及有发生以下情况：</strong></p>
<p><strong>end1越界了，那直接修改end1 &#x3D; n（长度）-1</strong></p>
<p><strong>begin2 越界，那此时就要修改begin2和end2，因为判断条件是begin2 &lt;&#x3D; end2，所以只需要让begin2&gt;end2即可</strong></p>
<p><strong>end2越界，此时需要将end2修改为 n（长度）-1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">void MergeSortNonR(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	//间隔 gap</span><br><span class="line">	int gap = 1;</span><br><span class="line">	int* tmp = (int*)malloc(sizeof(int)*n);</span><br><span class="line"></span><br><span class="line">    //如果间隔大于长度，就不用比了</span><br><span class="line">	while (gap &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">        //每次都遍历一遍数组</span><br><span class="line">		for (int i = 0; i &lt; n; i += 2 * gap)</span><br><span class="line">		&#123;</span><br><span class="line">			int begin1 = i, end1 = i + gap - 1;</span><br><span class="line">			int begin2 = i + gap, end2 =i+2*gap - 1;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">            //判断可能越界的值</span><br><span class="line">			if (end1 &gt;= n)</span><br><span class="line">				end1 = n - 1;</span><br><span class="line"></span><br><span class="line">			// begin2 越界，第二个区间不存在</span><br><span class="line">			if (begin2 &gt;= n)</span><br><span class="line">			&#123;</span><br><span class="line">				begin2 = n;</span><br><span class="line">				end2 = n - 1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// begin2 ok， end2越界，修正end2即可</span><br><span class="line">			if (begin2 &lt; n &amp;&amp; end2 &gt;= n)</span><br><span class="line">				end2 = n - 1;</span><br><span class="line"></span><br><span class="line">            //这里完全是为了好看，如果报错这里可以看到每次的区间</span><br><span class="line">			printf(&quot;%d %d %d %d\n&quot;, begin1, end1, begin2, end2);</span><br><span class="line"></span><br><span class="line">            //归并</span><br><span class="line">			int pos = begin1;</span><br><span class="line">			while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)</span><br><span class="line">			&#123;</span><br><span class="line">				if (a[begin1] &lt; a[begin2])</span><br><span class="line">					tmp[pos++] = a[begin1++];</span><br><span class="line">				else</span><br><span class="line">					tmp[pos++] = a[begin2++];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			//也许是其中一个数组放完了，另一个还没有，所以判断一下</span><br><span class="line">			while (begin1 &lt;= end1)</span><br><span class="line">				tmp[pos++] = a[begin1++];</span><br><span class="line"></span><br><span class="line">			while (begin2 &lt;= end2)</span><br><span class="line">				tmp[pos++] = a[begin2++];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			//别忘了拷贝过去</span><br><span class="line">			memcpy(a, tmp, sizeof(int)*end2);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		gap = gap * 2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    //用完了释放，别忘记了</span><br><span class="line">	free(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>时间复杂度：O（N*logN）</strong></p>
<p><strong>空间复杂度：O（N）</strong></p>
<p><strong>不好用，别用</strong></p>
<hr>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>一个比较简单的排序，如果理解的话，应该是这样理解的</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200935506.png"></p>
<p>这是要排序的数组，先建立一个数组，这个数组的大小应该是要排序里面数字的最大值</p>
<p>举个例子，这里最大的是9，所以就要开辟 10 个整型的空间（因为只有10个空间最后的下标才是9）</p>
<p>将待排序的数组元素作为下标，放到开辟空间对应的下标处，每放一个，就+1（初始化0）</p>
<p>打印的时候再将开辟数组里面不为0的地方打印出来</p>
<p>比方说这里有 2个3，那新开辟数组下标为3的位置就有 2 个，到时候返回就多返回一个</p>
<hr>
<p>但是这样做有一个坏处，就是，如果用最大数字来开辟空间的话，那假设是这样的一个数组</p>
<p>10000 5000  9999   8888</p>
<p>最大值10000，也就是说要开辟10000个整型的空间，但前面4999个都用不到</p>
<p>于是就有了优化版本</p>
<p>以最小的为参考值</p>
<p>这里是5000</p>
<p>开辟空间时开辟 最大值-最小值+1的空间</p>
<p>放数据的时候再-一个最小值</p>
<p>再之后打印的时候再+最小值</p>
<p>比方说5000，它放进去的时候-5000，就会放到 0 的位置</p>
<p>打印的时候 0+ 5000，所以打印出来的就是5000</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 计数排序</span><br><span class="line">void CountSort(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">    //找最大最小值</span><br><span class="line">	int max, min;</span><br><span class="line">	max = min = a[0];</span><br><span class="line">	int i;</span><br><span class="line">	for (i = 1; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (a[i] &gt; max)</span><br><span class="line">		&#123;</span><br><span class="line">			max = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		if (a[i] &lt; min)</span><br><span class="line">		&#123;</span><br><span class="line">			min = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//开辟空间</span><br><span class="line">	int range = max - min + 1;</span><br><span class="line">	int* arr = (int*)calloc(range, sizeof(int));</span><br><span class="line">	assert(arr);</span><br><span class="line"></span><br><span class="line">	//开始计数</span><br><span class="line">	for (i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[a[i]-min] +=1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//放回原数组</span><br><span class="line">	int j = 0;</span><br><span class="line">	for (i = 0; i &lt; range; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		while (arr[i]--)</span><br><span class="line">		&#123;</span><br><span class="line">			a[j++] = i+min;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	//释放空间</span><br><span class="line">	free(arr);</span><br><span class="line">	arr = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>时间复杂度：O（N+Range（数据范围））</p>
<p>空间复杂度：O（N+Range（数据范围））</p>
<p><strong>适用于范围比较集中、数据量大的情况，如果类似 10000 1</strong></p>
<p><strong>还是不要用这种了</strong></p>
<hr>
<h2 id="稳定性："><a href="#稳定性：" class="headerlink" title="稳定性："></a>稳定性：</h2><p>排序除了时间复杂度和空间复杂度以外，还有一个值得比较的是它的稳定性</p>
<p>稳定性可以用下图理解：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208200935009.png"></p>
<p>原本红色的99在黑的前面，现在排完序它们之间的相对位置还是没变，红的还是在黑的前面</p>
<p>上面的八个排序中：</p>
<p><strong>1.插入排序：稳</strong></p>
<p><strong>每次移动一个，原本在前面的在移动后面的时候也不会变位</strong></p>
<p><strong>2.希尔排序：不稳</strong></p>
<p><strong>如果有两个同样的数据但被分到不一样的组，那之后调整就可以出问题</strong></p>
<p><strong>3.选择排序：不稳</strong></p>
<p><strong>3 3  1  1</strong></p>
<p><strong>假设原本是这样的，将1调整到第一位的时候，原本第一位的3会来到第三位，这样就会出问题</strong></p>
<p><strong>4.堆排序：不稳</strong></p>
<p><strong>堆排序建大堆小堆直接就乱了</strong></p>
<p><strong>5.冒泡排序：稳</strong></p>
<p><strong>每次都只是交换，前后位置还是不变的</strong></p>
<p><strong>6.快速排序：不稳</strong></p>
<p><strong>每次分割一半，兴许哪一次就出现问题</strong></p>
<p><strong>7.归并排序：稳（不稳）</strong></p>
<p><strong>如果两数一样时都放第一个数组元素，那它就是稳的，如果放第二个数组，那就是不稳的</strong></p>
<p><strong>8.计数排序：不稳</strong></p>
<p><strong>它只管计数，然后放回去，不会管先放的是哪个</strong></p>

        </div>

        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/05/12/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">基础知识</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/04/11/%E4%BA%8C%E5%8F%89%E6%A0%91/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">二叉树的练习题</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2023&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Knous</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text">希尔排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">4.</span> <span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">5.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">6.</span> <span class="nav-text">快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81hoare%E7%89%88%EF%BC%9A"><span class="nav-number">6.1.</span> <span class="nav-text">1、hoare版：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%8C%96%E5%9D%91%E6%B3%95"><span class="nav-number">6.2.</span> <span class="nav-text">2、挖坑法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%89%8D%E5%90%8E%E6%8C%87%E9%92%88%E6%B3%95"><span class="nav-number">6.3.</span> <span class="nav-text">3、前后指针法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%BF%AB%E6%8E%92"><span class="nav-number">6.4.</span> <span class="nav-text">如何优化快排</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">6.5.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6"><span class="nav-number">7.</span> <span class="nav-text">归并</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E5%BD%92%E5%B9%B6"><span class="nav-number">7.1.</span> <span class="nav-text">非递归实现归并</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">8.</span> <span class="nav-text">计数排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%B3%E5%AE%9A%E6%80%A7%EF%BC%9A"><span class="nav-number">9.</span> <span class="nav-text">稳定性：</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
