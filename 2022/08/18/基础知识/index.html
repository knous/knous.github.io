<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/Knous.png"/>
	<link rel="shortcut icon" href="/img/Knous.png">
	
			    <title>
    Knous
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="Knous" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 6.2.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">Knous</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/Linux/">Linux</a></li><li><a class="category-link" href="/categories/test/">test</a></li><li><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="关于我">
		                关于我
		            </a>
		        </li>
		        
		        <li>
		            <a href="/Learn/" title="学习记录">
		                学习记录
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/knous" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url();background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >基础知识</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h1 id="test"><a href="#test" class="headerlink" title="test"></a>test</h1><hr>
<h2 id="C-是什么："><a href="#C-是什么：" class="headerlink" title="C++是什么："></a>C++是什么：</h2><p>用较为简单易懂的话来解释，就是在C的基础上改进的新语言，+的意思就是PLUS，因为是基于C语言的改进，所以引入了一些新的概念、语法，同时它也兼容C。</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>跟C语言一样，C++同样有一些平时常用的单词，例如int char之类的，这里我放一张表，记不住也没有关系，之后学了才会有更深的理解。</p>
<p>下面是表：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201045410.png"></p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>这里要提到的一点是命名空间，相较于其他关键字，namespace出现的频率会高一些，在C++程序里的前几排，总有这么一行代码：</p>
<p>using namespace std；</p>
<p>要想理解这句话，就应该从什么是namespace说起，先来看一下官方的解释：</p>
<blockquote>
<p>在C&#x2F;C++中，变量、函数和后面要学到的类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染，namespace关键字的出现就是针对这种问题的。</p>
</blockquote>
<p>如何理解？</p>
<p>举个例子，现在，我有两个变量都叫A,那我运行程序的时候程序肯定会报错，因为它不知道要用的是哪个A。</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201045949.png"></p>
<p>这种情况下，就可以用到namespace。</p>
<p>以下面情况举个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">namespace N1</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int a;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace N2</span><br><span class="line">&#123;</span><br><span class="line">    int a1 = 10;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace N3</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int c;</span><br><span class="line">namespace N2</span><br><span class="line">&#123;</span><br><span class="line">    int a1 = 10;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>两种都是可以的，namespace的作用就是将花括号里面的内容单独开辟一块空间出来，这块空间是不会与主程序产生冲突。</p>
<p>函数、结构体…这些都是可以放在命名空间里面的。</p>
<p>命名空间是可以嵌套使用的，但如果命名空间的名字相同，比如说这块空间是N1,另一块空间也是N1，那最后处理的时候它们就会合并到一起去。</p>
<p>命名空间就像新开辟了一块空间，命名空间里面的内容都局限于这一块空间中</p>
<p>如果要调用这块命名空间的内容，那就有两种办法，第一，是指定一块空间让系统在那里面去找。</p>
<p>举个例子</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201046359.png"></p>
<p>这里就是很典型的例子，可以看到主程序里面并没有a1，但是我在它的左边加了两个双引号，并在双引号左边加了一个N2。</p>
<p>这行代码就是让程序在N2这块空间里面找一个叫a1的数字。</p>
<p>第二种办法是直接释放这块命名空间，第一种办法每次都只是去找其中一个元素，使用的次数一多，每次都加双引号和命名空间名是件很麻烦的事，所以为了解决这个问题可以一次将这里面的元素释放出来，这就需要在前面加一句</p>
<p>using namespace xxx；</p>
<p>这里又有两种用法，第一种是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using N2::a1</span><br></pre></td></tr></table></figure>

<p><img src="/%22%E7%82%B9%E5%87%BB%E5%B9%B6%E6%8B%96%E6%8B%BD%E4%BB%A5%E7%A7%BB%E5%8A%A8%22"></p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201046360.png"></p>
<p>意思是将N2里面的a1元素释放出来，如果嵌套的很多，那就要加更多的引号。</p>
<p>第二种：一次释放完全</p>
<p>使用办法：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201046087.png"></p>
<p>如果是一次释放完全的话，那就应该在前面加上namespace，表明释放的是一块命名空间而不是单个元素。</p>
<p>那之前提到的：</p>
<p>using namespace std；</p>
<p>的意思就是将std里面的全部东西释放出来，经常使用的函数等…</p>
<h2 id="C-输入-amp-输出"><a href="#C-输入-amp-输出" class="headerlink" title="C++输入&amp;输出"></a>C++输入&amp;输出</h2><p>就好像新学C语言是先在屏幕上打印一个“hello world”一样，C++也先从这里开始比较好。</p>
<p>先输出吧，C++的输出跟C的区别这里就能看出来，假设要打印一句：hello world</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201046784.png"></p>
<p>cout表示要输出东西，随后用两个左箭头，再用双引号将文本括起来，最后再用两个左箭头隔开，endl是换行的意思。</p>
<p>这里有几点要注意：</p>
<blockquote>
<ol>
<li>使用cout标准输出(控制台)和cin标准输入(键盘)时，必须包含&lt; iostream &gt;头文件以及std标准命名空间。</li>
</ol>
<p>注意：早期标准库将所有功能在全局域中实现，声明在.h后缀的头文件中，使用时只需包含对应头文件即可，后来将其实现在std命名空间下，为了和C头文件区分，也为了正确使用命名空间，规定C++头文件不带.h；旧编译器(vc 6.0)中还支持&lt;iostream.h&gt;格式，后续编译器已不支持，因此推荐使用 <iostream>+std的方式。</p>
<ol start="2">
<li>使用C++输入输出更方便，不需增加数据格式控制，比如：整形–%d，字符–%c</li>
</ol>
</blockquote>
<p>头文件肯定是要包含的，std命名空间要用记得释放。</p>
<p>这里要说的是第二点，C++输出的时候不要增加类型，编译器会自动识别，这里将输入也连起来：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201046983.png"></p>
<p>创建三个变量，输入有要用cin，随后顺序输入,中间用向右的箭头连接，表示下一个输入的是它。</p>
<p>输入的时候跟刚刚一样，只不过中间的空格需要手打比较麻烦，不过这里可以看到没有提示类型它也可以直接输出，相较C舒服多了。</p>
<h2 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h2><p>这里是跟C差异较大的地方，在C里面，函数声明有几个参数，那你传过去就要几个参数，但是在C++里面，就不是这样的。</p>
<p>先从概念说起：</p>
<blockquote>
<p>缺省参数是声明或定义函数时为函数的参数指定一个默认值。在调用该函数时，如果没有指定实参则采用该默认值，否则使用指定的实参。</p>
</blockquote>
<p>举个例子：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201046175.png"></p>
<p>这里就是调用了缺省参数，我参数里面接受类型里面定义了一个变量a，但是我传参数的时候缺没有传a的值过去，那C++就默认用函数参数里面定义的那个值，这里是 10。</p>
<p>但是如果我传来一个参数过去：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201046909.png"></p>
<p>这里如果我传了一个2作为参数过去，那函数调用就会优先使用我传过去的参数。</p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>在C里面，函数名是不可以冲突的，但是在C++里面，就不会有这个问题，举个例子：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201046095.png"></p>
<p>这里就是重载函数，它函数名一样，但是函数的参数不一样，根据我传过去的参数不同，系统会调用对应的函数。</p>
<p>然后，再来看一下对于重载的说明：</p>
<blockquote>
<p>函数重载:是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表(参数个数 或 类型 或 顺序)必须不同，常用来处理实现功能类似数据类型不同的问题。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">short Add(short left, short right) </span><br><span class="line">&#123;</span><br><span class="line"> return left+right; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Add(short left, short right) </span><br><span class="line">&#123;</span><br><span class="line"> return left+right; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这算吗？</p>
<p>它的函数名不同吗？</p>
<p>它的参数个数不同吗？</p>
<p>它的参数类型不一样吗？</p>
<p>但是它只有返回值不一样，所以它并不算重载参数。</p>
<h2 id="重载参数的实现"><a href="#重载参数的实现" class="headerlink" title="重载参数的实现"></a>重载参数的实现</h2><p>这里就要从底层实现开始说，当程序开始运行的时候，它会经过几个阶段：</p>
<p>1、预处理：头文件展开、宏的替换、条件编译、去掉注释</p>
<p>这里会生成 .I文件</p>
<p>2、编译：检查语法，生成汇编代码</p>
<p>这里生成 .s 文件</p>
<p>3、汇编：将汇编代码转换为二进制的机器码</p>
<p>这里生成 .o文件</p>
<p>4、连接：开始找要调用的函数地址，然后将其连接在一起</p>
<p>这里生成  .out文件</p>
<p>那函数重载，C&#x2F;C++就是在连接部分不一样，因为我还不会Linux，所以这里先说一下结论，之后再将详细过程写出来。</p>
<p>总之，C在连接过程中会很简单的将函数名对应起来，如果相同那它就会产生冲突</p>
<p>但是C++不是，它的函数名对应是这样的：_Z+函数名+参数首字母</p>
<p>假设是这样的一个函数：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201046864.png"></p>
<p>C里面应该是两个fun函数，但是C++是这样的：_Z3i 和 _Z3d</p>
<p>因为函数名的参数不一样，它的函数名就不一样，所以在找的时候就不会有冲突问题。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>这个我个人认为是指针的改版，举个例子：</p>
<p>我现在要交换两个数，如果是指针，那应该这么写：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201046133.png"></p>
<p>如果是用引用，那它应该是这样的</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201046909.png"></p>
<p>同样可以达成想要的效果，那再来看看引用的解释：</p>
<p>引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。</p>
<p>类型&amp; 引用变量名(对象名) &#x3D; 引用实体；</p>
<p>这里要注意两点，引用类型应该和引用实体是一个类型（但是如果不是一个类型，加一个const也是可以的）。</p>
<h3 id="引用特性"><a href="#引用特性" class="headerlink" title="引用特性"></a>引用特性</h3><blockquote>
<ol>
<li>引用在定义时必须初始化 </li>
<li>一个变量可以有多个引用</li>
<li>引用一旦引用一个实体，再不能引用其他实体</li>
</ol>
</blockquote>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201047303.png"></p>
<p>这是可行的，但是如果引用没有初始化，那就会报错：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201047689.png"></p>
<p>同时，还可以：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201047829.png"></p>
<p>引用引用（套娃）</p>
<p>但是引用只有一个对象，不能再引用其他对象，这里就要注意下。</p>
<p>同时，这里还要注意一点：</p>
<p>引用只能将权限缩而不能放大：</p>
<p>举个例子：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201047856.png"></p>
<p>在这里就是一个很明显的例子，const修饰的对象是不能被修改的，而你引用的权限是可以修改，所以就会报错。</p>
<p>如果要引用，那在引用的时候就应该也带上const<img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201047918.png"></p>
<p>引用还可以作为返回值，作为返回值返回的是那一块空间的地址。</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201047256.png"></p>
<p>但是这种是错误的示范，因为函数返回的是n的别名（本质还是地址），但是n是一个局部变量，出了函数就会销毁，在销毁之后再去访问就会出现问题——越界。</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201047474.png"></p>
<p>再看这样一个代码，这里拿ret来接收了它的返回值，但是之后又调用了这个函数，在之后打印结果是？</p>
<p>本意是 3.但是引用返回的是c的地址，在1+2后又对这一块空间进行修改：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201047881.png"></p>
<p>所以它就出错了。</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201047081.png"></p>
<p>如果再次看结果，这就是一个随机值了，因为这一块空间已经归还给了系统，再去看就被刷新了。</p>
<h3 id="引用的效率问题"><a href="#引用的效率问题" class="headerlink" title="引用的效率问题"></a>引用的效率问题</h3><p>值和引用的作为返回值类型的性能比较</p>
<p>如果是这样的一个程序：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201047853.png"></p>
<p>明明c的寿命周期已经到了，那为什么还能返回？</p>
<p>因为系统会将这个值暂存下来，可以理解为临时拷贝一份，那既然是临时拷贝，这效率就可以直说。</p>
<p>它没有引用块，假设这个数据很大，有一百万个数据，一千万个数据 ，那拷贝就要耗时间，而引用是直接返回地址，所以会更快。</p>
<p>相较于指针，引用和指针应该是一个级别。</p>
<h2 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h2><blockquote>
<p>在概念上，指针是一块地址，引用是变量的别名，它们占用空间就有区别</p>
<p>但底层实际方面，引用跟指针实现方式很像，也是要占用一块空间的。</p>
</blockquote>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201047391.png"></p>
<blockquote>
<ol>
<li>引用在定义时必须初始化，指针没有要求</li>
<li>引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型</li>
</ol>
<p>实体</p>
<ol start="3">
<li>没有NULL引用，但有NULL指针</li>
<li>在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占</li>
</ol>
<p>4个字节)</p>
<ol start="5">
<li>引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小</li>
<li>有多级指针，但是没有多级引用 </li>
<li>访问实体方式不同，指针需要显式解引用，引用编译器自己处理 </li>
<li>引用比指针使用起来相对更安全</li>
</ol>
</blockquote>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>当使用函数的时候，会有这么一种情况，就是：如果这个函数很短，但是需要用的地方很多，比方说实现一个A+B的函数，有没有什么办法可以解决这个问题？</p>
<p>当然，宏，那宏是怎么写的呢？</p>
<p>这里给你十秒，想一个宏实现A+B。</p>
<p>想出来了吗？</p>
<hr>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201047389.png"></p>
<p>因为宏直接替换，不好理解而且不方便查看过程，很容易出错，那这里就引入一个概念叫内联函数。</p>
<p>这里先看一下内联函数的定义：</p>
<blockquote>
<p>以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销，内联函数提升程序运行的效率。</p>
</blockquote>
<p>要理解这句话，要先理解什么是函数栈帧，每调用一个函数，都会在内存中开辟一块空间，然后压栈。</p>
<p>但如果是使用内联函数，那么程序运行就会直接在函数调用地方展开，不压栈，这样效率会更高。</p>
<p>但是如果这个函数很长，再用内联函数的话，每次调用都展开未免也有点太长了，所以编译器在执行的时候会先判断这个函数内容多不多，如果这个函数内容很多，它会不执行内联，如果很短，它会先替换。</p>
<p>那么多少代码算长的？</p>
<p>10行左右。</p>
<p>如果你想，所有函数前面都可以加一个inline，让编译器自己判断。</p>
<hr>
<h3 id="内联函数的特性"><a href="#内联函数的特性" class="headerlink" title="内联函数的特性"></a>内联函数的特性</h3><blockquote>
<ol>
<li>inline是一种以空间换时间的做法，省去调用函数额开销。所以代码很长或者有循环&#x2F;递归的函数不适宜使用作为内联函数。</li>
<li>inline对于编译器而言只是一个建议，编译器会自动优化，如果定义为inline的函数体内有循环&#x2F;递归等等，编译器优化时会忽略掉内联。</li>
<li>inline不建议声明和定义分离，分离会导致链接错误。因为inline被展开，就没有函数地址了，链接就会找不到。</li>
</ol>
</blockquote>
<p>这里重点要了解第三条，如果分离，展开的时候就找不到函数本体，这里看一个例子：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201047299.png"></p>
<p>在Code.h里面我声明了一个内联函数，但是我没有定义，而是在：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201047669.png"></p>
<p>Code.h里面定义了这个函数，如果现在要用这个函数，会发生什么？</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201047740.png"></p>
<p>无法解析的外部符号，这里就可以直接理解为程序运行的时候找不到这个函数，但是我明明声明了这个函数，为什么还是找不到？</p>
<p>因为inline被展开之后它没有定义，只是一个声明，既然只有一个声明那它怎么可能调用呢？</p>
<p>这里要注意一下。</p>
<p>这里把宏的优缺点说一下：</p>
<blockquote>
<p>优点：</p>
<p>1.增强代码的复用性。</p>
<p>2.提高性能。</p>
<p>缺点：</p>
<p>1.不方便调试宏。（因为预编译阶段进行了替换）</p>
<p>2.导致代码可读性差，可维护性差，容易误用。</p>
<p>3.没有类型安全的检查 。</p>
</blockquote>
<blockquote>
<p>C++有哪些技术替代宏？</p>
<ol>
<li>常量定义 换用const</li>
<li>函数定义 换用内联函数</li>
</ol>
</blockquote>
<p>这里第一条有在《EffectiveC++》的条款里面提到：</p>
<blockquote>
<p>EffectiveC++ 条款02：尽量以const,enum,inline替换#define</p>
</blockquote>
<p>这里看图：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201047838.png"></p>
<p>可以看到，maxa已经有值了，但是无法识别出MAX。</p>
<p>为了解决这种类似问题，就可以用const——无法修改的变量和enum枚举常量来代替。</p>
<h2 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h2><p>当定义一个变量的时候，应该是这样定义的：</p>
<p>int i &#x3D; 1；</p>
<p>float j &#x3D; 1.1；</p>
<p>char k &#x3D; ‘A’;</p>
<p>auto的作用就是，它会根据后面变量的数值来给类型：</p>
<blockquote>
<p>在早期C&#x2F;C++中auto的含义是：使用auto修饰的变量，是具有自动存储器的局部变量，但遗憾的是一直没有人去使用它，大家可思考下为什么？</p>
<p>C++11中，标准委员会赋予了auto全新的含义即：auto不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得。</p>
</blockquote>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201048339.png"></p>
<p>如果用auto，是怎么样的？</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201048011.png"></p>
<p>可以看到基本是一样的。</p>
<p>但如果开始并未赋值，就会报错：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201048628.png"></p>
<p>因为auto是根据后面的值来判断类型，如果不给值那它就无法判断。</p>
<p>如果用auto来定义指针，会发生什么？</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201048721.png"></p>
<p>可以看到，如果是auto + &amp;，那auto就会默认是int*</p>
<p>如果是第二种，auto后面已经带<em>了，那auto还是int</em>。</p>
<p>如果是引用，那就应该是这样：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201048440.png"></p>
<p>还要注意，如果一行定义多个变量，那这些变量都应该是一个类型：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201048581.png"></p>
<p>同时，它不能作为函数参数：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201048107.png"></p>
<p>还是那句，它是根据后面的值来给类型的，并且必须初始化。</p>
<p>同时，不能声明数组：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201048494.png"></p>
<h3 id="auto在for循环内部"><a href="#auto在for循环内部" class="headerlink" title="auto在for循环内部"></a>auto在for循环内部</h3><p>以往，遍历数组是这样的</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201048909.png"></p>
<p>现在，可以用auto：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201048969.png"></p>
<p>它会自己遍历每个数打印，那能不能直接修改呢？</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201048916.png"></p>
<p>可以看到，第一个遍历已经修改了里面的值，但是到了第二个遍历可以看到还是原来的值。</p>
<p>这是因为这里面的e是一份临时拷贝而不是对应的那个值，如果通过这个修改值，那有什么方法？</p>
<p>别名。</p>
<p>可以看下图：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201048887.png"></p>
<p>这样就可以了。</p>
<h2 id="指针空值nullptr"><a href="#指针空值nullptr" class="headerlink" title="指针空值nullptr"></a>指针空值nullptr</h2><p>这个是后来的规定，大致意思：</p>
<p>C语言有以下两种办法指定空指针：</p>
<p>int*p &#x3D; 0；</p>
<p>int* pp &#x3D; NULL；</p>
<p>这两种都是制定为空指针，但是在C++（11）的标准里面，不算规范写法，是因为这两种写法的等价的：</p>
<blockquote>
<p>#ifndef NULL</p>
<p>#ifdef __cplusplus</p>
<p>#define NULL 0</p>
<p>#else</p>
<p>#define NULL ((void *)0)</p>
<p>#endif</p>
<p>#endif</p>
</blockquote>
<p>这是网上找到的C头文件，可以看到这里是直接讲 NULL替换为 0，或者是void类型的指针。</p>
<p>这里有办法可以看看：</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201048000.png"></p>
<p>这是一个重载函数，但区别是一个是指针一个是整形，前面两个传参是 0 和NULL，看右边可以看出来它们调用的都是整形的函数，这里就可以看出来NULL跟0是一样的，而如果在传参时将NULL强转为int*，那它才会调用第二个函数。</p>
<p>那规范的空指针写法是什么样的？</p>
<p><img src="https://knous.oss-cn-nanjing.aliyuncs.com/PicGo/202208201048699.png"></p>
<p>如图，nullptr是规范的空指针写法，传过去的也是一个指针。</p>
<p>这里有几点注意：</p>
<blockquote>
<p>nullptr是关键字，不需要头文件</p>
<p>C++11中，sizeof(nullptr) 与sizeof((void*)0所占的字节数相同</p>
<p>能用nullptr，就用nullptr，这样比较规范</p>
</blockquote>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://example.com/2022/08/18/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://example.com/2022/08/18/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
